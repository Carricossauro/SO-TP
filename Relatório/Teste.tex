
\documentclass[11pt,a4paper]{report}

\usepackage[portuges]{babel}
\usepackage[utf8]{inputenc} % define o encoding usado texto fonte (input)--usual "utf8" ou "latin1
\usepackage{graphicx} %permite incluir graficos, tabelas, figuras
\usepackage{subcaption}
\usepackage{listings}
\usepackage{color}
\usepackage{multicol}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float} 

\definecolor{myblue}{rgb}{0.2,0.2,0.8}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstdefinestyle{code}{ 
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{white},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  firstnumber=1000,                % start line enumeration with line 1
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C++,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\title{Sistemas Operativos - Trabalho Prático\\
       \textbf{Grupo 17}\\ Relatório
       } %Titulo do documento
%\title{Um Exemplo de Artigo em \LaTeX}
\author{Inês Pires Presa\\ (A90355)\and Ivo Miguel Gomes Lima\\ (A90214)\and Tiago dos Santos Silva Peixoto Carriço \\ (A91695)
       } %autores do documento
\date{\today} %data

\begin{document}
	\begin{minipage}{0.9\linewidth}
        \centering
		\includegraphics[width=0.4\textwidth]{um.jpeg}\par\vspace{1cm}
                \href{https://www.uminho.pt/PT}
		{\scshape\LARGE Universidade do Minho} \par
		\vspace{0.6cm}
                \href{https://lcc.di.uminho.pt}
		{\scshape\Large Licenciatura em Ciências da Computação} \par
		\maketitle
		\begin{figure}[H]
			\includegraphics[width=0.32\linewidth]{ines.jpg}
			\includegraphics[width=0.32\linewidth]{ivo.jpg}
			\includegraphics[width=0.32\linewidth]{tiago.jpg}
		\end{figure}
	\end{minipage}

\tableofcontents % insere Indice

\chapter{Introdução}

Foi-nos proposto, no âmbito da unidade curricular de Sistemas Operativos, o desenvolvimento de um sistema capaz de transformar vários ficheiros de áudio concurrentemente, consultar as tarefas em execução, mostrando ainda o número de filtros disponiveis e em uso nessas transformações. Este tipo de sistema utiliza um conjunto de executáveis utilizados para filtrar e modificar um fluxo de áudios, permitindo tratar grandes quantidades de dados explorando a concorrência entre os diferentes processos.

Neste relatório,vamos explicitar a nossa abordagem ao problema, justificando a estrutura do nosso sistema, demonstrando os conhecimentos adquiridos durante as aulas, tais como a utilização/criação de processos, duplicação de descritores, criação de \emph{pipes} sem/com nome, execução de processos, aplicação de sinais e \emph{system calls}.

\chapter{Funcionalidades}

\section{Aplicação de Filtros}

Submetendo um comando do tipo \emph{./aurras transform}, seguido dos nomes do ficheiro original assim como do ficheiro processado e de uma sequência de identificadores de filtros, o programa aplica-os ao primeiro ficheiro, guardando o resultado final no segundo. Esta ação só não será efetuada caso seja pedido que algum dos filtros seja aplicado um número de vezes superior ao máximo definido no ficheiro de configuração. Quando esse valor é alcançado devido à pré-existência de pedidos, este fica em lista de espera para que possa ser posteriormente processado.

\section{Verifição do Estado}

Caso o comando seja do tipo \emph{./aurras status}, o cliente recebe do servidor uma descrição dos pedidos que estão a ser processados, assim como uma lista dos filtros em utilização e a identificação do \emph{pid} do servidor.

\section{Informação de Utilização}

Na eventualidade de o utilizador pretender obter informação relativa às funcionalidades suportadas pelo cliente (servidor), este terá de digitar \emph{./aurras} (\emph{./aurrasd}). 

\chapter{Estrutura de implementação}

\section{Cliente (\emph{aurras.c})}

Para a implementação das funcionalidades referidas anteriormente, foi necessário a criação de duas funções \emph{status} e \emph{transform} que serão brevemente descritas de seguida.

 \begin{itemize}
\item \textbf{Status: } São criados dois \emph{pipes} com nome que fazem a ligação com o servidor. O \emph{pipe\_escrever} é empregue para o envio do pedido de verificação do estado conduzido pelo cliente, em contrapartida o \emph{pipe\_ler} recebe a informação solicitada que será imprimida no \emph{standard output}. O \emph{pid} do cliente é enviado através do \emph{pipePrincipal} para o servidor.
\item \textbf{Transform: } Nesta função só é criado um \emph{pipe\_escrever}, uma vez que o método de comunicação que definimos no sentido servidor -\textgreater cliente é a utilização de sinais. Desta forma, o \emph{pipe} é utilizado para enviar a informação referente ao pedido de transformação do ficheiro, quando o processo é iniciado o cliente recebe um sinal (\emph{SIGUSR1}).
\end{itemize}

\section{Servidor (\emph{aurrasd.c})}

\subsection{Variáveis Globais}

\begin{itemize}
\item \textbf{struct lligada: } Esta \emph{struct} serve para armazenar as informações presentes no ficheiro de configuração, nomeadamente  o nome do filtro, o nome do executável e o número máximo de uso simultâneo desse filtro, para além disso guarda também o número de utilizações no momento do mesmo.
\item \textbf{struct quantidade\_filtro: } Esta estrutura de dados tem a funcionalidade de manter o nome de um filtro assim como a quantidade de utilizações presentes num certo comando.
\item \textbf{struct tasks: } Neste caso a \emph{struct} desempenha o papel de guardar os dados mais relevantes de um pedido, acrescentando ainda 
\end{itemize}

\begin{lstlisting}[style = code]
typedef struct lligada {
    char *nome_filtro;
    char *nome_executavel;
    int maximo;
    int atual;
    struct lligada *prox;
} *Filtro;
\end{lstlisting}

Na \emph{struct lligada}

\begin{lstlisting}[style = code]
struct quantidade_filtro {
    char *nome_filtro;
    int utilizacoes;
};
\end{lstlisting}

Na \emph{struct quantidade\_filtro}

\begin{lstlisting}[style = code]
typedef struct tasks {
    char *comando;
    char **ordem_filtros;
    struct quantidade_filtro *nomes_filtros;
    int numero;
    int processamento; // 0 - a espera; 1 - a processar
    int pid;
    char *input_file;
    char *output_file;
    struct tasks *prox;
} *Task;
\end{lstlisting}

Na \emph{struct tasks}

\begin{itemize}
\item \textbf{Filtro filtros :}
\item \textbf{Task tasks = NULL :}
\item \textbf{char *pasta\_filtros :}
\item \textbf{int numero\_tasks = 0 :}
\end{itemize}

\chapter{Conclusão}

Durante a realização deste trabalho prático embora o mesmo tenha sido apelidado de simples e até mesmo básico por parte da equipa docente, sentimos que exigiu uma grande organização da nossa parte para que não fosse perdido o foco do problema que estavamos a enfrentar. Tendo a aplicação dos conceitos teóricos revelado-se, de uma maneira geral, bastante interessante e desafiante pois tal como \emph{\textbf{Ward Cunningham}} disse \emph{\textbf{It's all talk until the code runs}}. 

Uma das peças fundamentais para a concretização do projeto foram as resoluções dos guiões práticos apresentadas pela equipa de docentes e até mesmo as nossas, pois serviram de apoio para o esclarecimento de dúvidas que surgiram, o que nos permitiu finalizar o mesmo com todas as funcionalidades solicitadas. Consideramos que a maior dificuldade foi sentida no momento inicial pois não conseguimos visualizar o produto final da nossa abordagem ao problema, mas conforme o estabelecimento de \emph{mini checkpoints} conseguimos ultrapassar este impasse.

\end{document}